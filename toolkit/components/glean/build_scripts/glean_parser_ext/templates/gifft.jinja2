// -*- mode: C++ -*-

/* This file is auto-generated by run_glean_parser.py.
   It is only for internal use by types in
   toolkit/components/glean/bindings/private */
{# The rendered source is autogenerated, but this
Jinja2 template is not. Pleas file bugs! #}

#include "mozilla/Maybe.h"
#include "mozilla/Telemetry.h"
#include "mozilla/DataMutex.h"
{% if probe_type == "Scalar" %}
#include "mozilla/Tuple.h"
#include "nsClassHashtable.h"
#include "nsTHashMap.h"
{% endif %}

#ifndef mozilla_glean_{{ probe_type }}GifftMap_h
#define mozilla_glean_{{ probe_type }}GifftMap_h

namespace mozilla::glean {

using Telemetry::{{ probe_type }}ID;

{% if probe_type == "Histogram" %}
typedef uint64_t TimerId; // Same as in TimingDistribution.h.
static StaticDataMutex<nsTHashMap<TimerId, TimeStamp>> gTimerIdToStarts("gTimerIdToStarts");
{% elif probe_type == "Scalar" %}
typedef nsUint32HashKey SubmetricIdHashKey;
typedef nsClassHashtable<SubmetricIdHashKey, Tuple<ScalarID, nsString>>
    SubmetricToLabeledMirrorMapType;
static StaticDataMutex<SubmetricToLabeledMirrorMapType> gLabeledMirrors("gLabeledMirrors");

namespace {
class ScalarIDHashKey : public PLDHashEntryHdr {
 public:
  typedef const ScalarID& KeyType;
  typedef const ScalarID* KeyTypePointer;

  explicit ScalarIDHashKey(KeyTypePointer aKey) : mValue(*aKey) {}
  ScalarIDHashKey(ScalarIDHashKey&& aOther)
      : PLDHashEntryHdr(std::move(aOther)), mValue(std::move(aOther.mValue)) {}
  ~ScalarIDHashKey() = default;

  KeyType GetKey() const { return mValue; }
  bool KeyEquals(KeyTypePointer aKey) const { return *aKey == mValue; }

  static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  static PLDHashNumber HashKey(KeyTypePointer aKey) {
    return static_cast<std::underlying_type<ScalarID>::type>(*aKey);
  }
  enum { ALLOW_MEMMOVE = true };

 private:
  const ScalarID mValue;
};
}  // namespace
static StaticDataMutex<nsTHashMap<ScalarIDHashKey, TimeStamp>> gTimespanStarts("gTimespanStarts");

static inline bool IsSubmetricId(uint32_t aId) {
  return aId > (1 << 27); // Kept in sync with js.py's ID_BITS, rust.py's min_submetric_id
}
{% endif %}

static{% if probe_type == "Event" %} inline{% endif %} Maybe<{{ probe_type }}ID> {{ probe_type }}IdForMetric(uint32_t aId) {
  switch(aId) {
{% for id, (mirror, metric_name) in ids_to_probes.items() %}
    case {{ id }}: { // {{ metric_name }}
      return Some({{ probe_type }}ID::{{ mirror }});
    }
{% endfor %}
    default: {
      return Nothing();
    }
  }
}

}  // namespace mozilla::glean
#endif  // mozilla_glean_{{ probe_type }}GifftMaps_h
